#include "DHT.h"
#include <U8g2lib.h>
#include <Wire.h>
#include <SPI.h>
#include <Adafruit_BMP280.h>

#define PIN_DHT 5 //pin dell'Arduino dove è collegato il sensore DHT
#define DHT_TYPE DHT11
#define DELAY_FRAME_DISPLAY //ritardo tra una frame e l'altra dell'animazione del display
#define IMAGE_WIDTH 47 //lunghezza in pixels dello schermo
#define IMAGE_HEIGHT 60 //altezza in pixels dello schermo
#define NAN_CONST -999.99 //valore che rappresenta il NaN
#define DELA 5000 //DELAY
#define NA "n/a"

//bit che compongono il disegno di una piantina
const static char piantina2_piccola_bits[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xE0, 0xFF, 0x00, 0x80, 0x7F, 0x00, 0xE0, 0xFF, 0x00, 0x80, 0x7F, 0x00,
  0xE0, 0xFF, 0x00, 0x80, 0x7F, 0x00, 0xE0, 0xFF, 0x00, 0x80, 0x7F, 0x00,
  0x1E, 0x00, 0x0F, 0x78, 0x80, 0x03, 0x1E, 0x00, 0x0F, 0x78, 0x80, 0x03,
  0x1E, 0x00, 0x0F, 0x78, 0x80, 0x03, 0xFE, 0xFF, 0xF0, 0x87, 0x07, 0x3C,
  0xFE, 0xFF, 0xF0, 0x87, 0x07, 0x3C, 0xFE, 0xFF, 0xF0, 0x87, 0x07, 0x3C,
  0xFE, 0xFF, 0xF0, 0x87, 0x07, 0x3C, 0x1E, 0x00, 0x70, 0x00, 0xF8, 0x3F,
  0x1E, 0x00, 0x70, 0x00, 0xF8, 0x3F, 0x1E, 0x00, 0x70, 0x00, 0xF8, 0x3F,
  0x1E, 0x00, 0x70, 0x00, 0xF8, 0x3F, 0x00, 0xFF, 0x70, 0xF8, 0x07, 0x00,
  0x00, 0xFF, 0x70, 0xF8, 0x07, 0x00, 0x00, 0xFF, 0x70, 0xF8, 0x07, 0x00,
  0x00, 0xFF, 0x70, 0xF8, 0x07, 0x00, 0xE0, 0x00, 0xFF, 0x07, 0x78, 0x00,
  0xE0, 0x00, 0xFF, 0x07, 0x78, 0x00, 0xE0, 0x00, 0xFF, 0x07, 0x78, 0x00,
  0x00, 0xFF, 0x70, 0xF8, 0x07, 0x00, 0x00, 0xFF, 0x70, 0xF8, 0x07, 0x00,
  0x00, 0xFF, 0x70, 0xF8, 0x07, 0x00, 0x00, 0xFF, 0x70, 0xF8, 0x07, 0x00,
  0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00,
  0xE0, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0x7F, 0x00,
  0xE0, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0x7F, 0x00,
  0xE0, 0x00, 0x00, 0x00, 0x78, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x78, 0x00,
  0xE0, 0x00, 0x00, 0x00, 0x78, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0x7F, 0x00,
  0xE0, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0x7F, 0x00,
  0xE0, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x0F, 0x00, 0x80, 0x07, 0x00,
  0x00, 0x0F, 0x00, 0x80, 0x07, 0x00, 0x00, 0x0F, 0x00, 0x80, 0x07, 0x00,
  0x00, 0x0F, 0x00, 0x80, 0x07, 0x00, 0x00, 0x0F, 0x00, 0x80, 0x07, 0x00,
  0x00, 0x0F, 0x00, 0x80, 0x07, 0x00, 0x00, 0x0F, 0x00, 0x80, 0x07, 0x00,
  0x00, 0x0F, 0x00, 0x80, 0x07, 0x00, 0x00, 0x0F, 0x00, 0x80, 0x07, 0x00,
  0x00, 0x0F, 0x00, 0x80, 0x07, 0x00, 0x00, 0x0F, 0x00, 0x80, 0x07, 0x00,
  0x00, 0xF0, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0x7F, 0x00, 0x00,
  0x00, 0xF0, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0xF0, 0xFF, 0x7F, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
  };

//inizializzazione della variabile schermo u8g2:
U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, U8X8_PIN_NONE);
//inizializzazione della variabile sensore DHT:
DHT dht(PIN_DHT, DHT_TYPE);
//inizializzazione della variabile sensore BMP280:
Adafruit_BMP280 bmp(BMP_CS);

//variabili che contengono il valore precedente di umidità, temperatura, pressione
 byte old_hum = 0;
 byte old_temp = 0;
 byte old_pres = 0;

//variabili che contengono l'informazione se il valore attuale è aumentato/rimasto stabile/diminuito rispetto a quello precedente
 int humVariazione = 0;
 int tempVariazione = 0;
 int presVariazione = 0;



 void setup()
 {
 //inizio letture e scritture su porta seriale
   Serial.begin(9600);

 //=============== DHT ================
   dht.begin();

 //================ OLED ===============
   u8g2.begin();
   u8g2_prepare();

 //================ BMP280 ===============
    bmp.begin();
 }


//funzione di impostazione dei font dell'OLED
void u8g2_prepare()
{
  u8g2.setFont(u8g2_font_6x10_tf);
  u8g2.setFontRefHeightExtendedText();
  u8g2.setDrawColor(1);
  u8g2.setFontPosTop();
  u8g2.setFontDirection(0);
}

//funzione di conversione tra il risultato della funzione di comparazione di due valori e una stringa rappresentativa
String esitoVariazione(int numeroVariazione)
{
  switch (numeroVariazione)
  {
    case -1 : return "-"; break;
    case 1 : return "+"; break;
    default: return "=";
  }
}

// SCRITTURA DELLA SCHERMATA CHE MOSTRA I VALORI RILEVATI A VIDEO
void disegna_rilevamento(float valhum, float valtemp, float valpres, int humVariazione, int tempVariazione, int presVariazione )
{

//pulitura del buffer:
  u8g2.clearBuffer();

  u8g2.setCursor(30, 5);
  u8g2.print(F("Dati Rilevati"));
  u8g2.setCursor(45, 17);
  u8g2.print(F("Hum"));
  u8g2.setCursor(75, 17);
  u8g2.print(F("Pa"));
  u8g2.setCursor(105, 17);
  u8g2.print(F("C\xb0"));
  // non spostare sotto questo primo pezzo di codice, se no per farlo grande bisogna istanziare un nuovo font e non ci sta...
  u8g2.setFont(u8g2_font_5x7_tr);
  u8g2.setFontPosTop();
  u8g2.setFontDirection(0);
  u8g2.setCursor(15, 43); //primo numero è la colonna, il secondo la riga
  u8g2.print("var");
  u8g2.setCursor(15, 31);
  u8g2.print("val");


  //val e var Hum
  if (valhum != NAN_CONST)
  {
    u8g2.drawStr(40, 31, String(valhum).c_str());
    u8g2.drawUTF8(40, 43, esitoVariazione(humVariazione).c_str());
  }
  else
  {
    u8g2.setCursor(40, 31);
    u8g2.print(F(NA));
  }
  //val e var temp
  if (valtemp != NAN_CONST)
  {
    u8g2.drawStr(95, 31, String(valtemp).c_str());
    u8g2.drawUTF8(95, 43, esitoVariazione(tempVariazione).c_str());
  }
  else
  {
  u8g2.setCursor(95, 31);
  u8g2.print(F(NA));
  }

//val e var pres
  if (valtemp != NAN_CONST)
  {
    u8g2.drawStr(70, 31, String(valpres).c_str());
    u8g2.drawUTF8(70, 43, esitoVariazione(presVariazione).c_str());
  }
  else
  {
    u8g2.setCursor(70, 31);
    u8g2.print(F(NA));
  }

//flush del buffer
  u8g2.sendBuffer();

}


// funzione di disegno dell'animazione a video
void u8g2_show_bitmap()
{
  u8g2.clearBuffer();
  u8g2.drawXBMP(43, 0, IMAGE_WIDTH, IMAGE_HEIGHT, piantina2_piccola_bits);
  u8g2.sendBuffer();
}


int calcolaVariazione(byte nuovo, byte vecchio)
{

  if (nuovo == NAN_CONST || vecchio == NAN_CONST) return 0;

  if (round(nuovo) > round(vecchio))
  {
    return 1;
    }
  else if (round(nuovo) < round(vecchio))
  {
    return -1;
    }
  else
  {
    return 0;
    }
}

float checkForNAN(float number)
{
  if(isnan(number))
  return NAN_CONST;
  else return number;
}


void loop()
{
  u8g2.clearBuffer();

  //lettura dei dati dai sensori
  float humFloat = dht.readHumidity();
  float tempFloat = dht.readTemperature();
  float presFloat = bmp.readPressure();

  humFloat = checkForNAN(humFloat);
  tempFloat = checkForNAN(tempFloat);
  presFloat = checkForNAN(presFloat);

  humVariazione = calcolaVariazione(byte(humFloat), byte(old_hum));
  tempVariazione = calcolaVariazione(byte(tempFloat), byte(old_temp));
  presVariazione = calcolaVariazione(byte(presFloat), byte(old_pres));

  old_hum = humFloat;
  old_temp = tempFloat;
  old_pres = presFloat;


// PARTE GRAFICA:
  disegna_rilevamento(humFloat, tempFloat, presFloat, humVariazione, tempVariazione, presVariazione);
  delay(DELA);

  u8g2_show_bitmap();
  delay(DELA);
  }
